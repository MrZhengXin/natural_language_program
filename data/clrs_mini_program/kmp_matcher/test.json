{"input": "Execute the instructions step by step. Do not jump steps. Do not stop before completion. When reading or updating an array at some index, use concrete values rather than just variables.\n\nInitial: Given a pattern string pat of length M and a text string txt of length N.\npat: pat[0] = A, pat[1] = A, pat[2] = A, M = 3.\ntxt: txt[0] = C, txt[1] = B, txt[2] = B, txt[3] = C, N = 4.\nCreate an array lps[] of length M with the value of 0: lps[0] = 0, lps[1] = 0, lps[2] = 0.\n\ndef KMPSearch(pat, txt):\n    # pat is a string of length M, and txt is a string of length N.\n    M = len(pat)\n    N = len(txt)\n \n    # create lps[] that will hold the longest prefix suffix\n    # values for pattern\n    lps = [0] * M\n\n \n    # Preprocess the pattern (calculate lps[] array)\n    length = 0  # length of the previous longest prefix suffix\n \n    i = 1\n \n    # the loop calculates lps[i] for i = 1 to M-1\n    while i < M:\n        if pat[i] == pat[length]:\n            length += 1\n            lps[i] = length\n            i += 1\n        else:\n            # This is tricky. Consider the example.\n            # AAACAAAA and i = 7. The idea is similar\n            # to search step.\n            if length != 0:\n                length_prev = length - 1\n                length = lps[length_prev]\n \n                # Also, note that we do not increment i here\n            else:\n                lps[i] = 0\n                i += 1\n    # End of while loop\n\n    print(lps) # And print lps[], displaying each value as \"lps[i] = lps_i\".\n \n    i = 0  # index for txt[]\n    j = 0  # index for pat[]\n    res = []\n\n    while (N - i) >= (M - j):\n        if pat[j] == txt[i]:\n            i += 1\n            j += 1\n        # End of if\n \n        if j == M:\n            found_index = i - j\n            res.append(found_index) # And print res\n            j = lps[j-1]\n        # End of j == M\n\n        # mismatch after j matches\n        elif i < N and pat[j] != txt[i]:\n            # Do not match lps[0..lps[j-1]] characters,\n            # they will match anyway\n            if j != 0:\n                j = lps[j-1]\n            else:\n                i += 1\n        # End of elif\n    # End of while\n\n    return res\n\n-----\nThe computation procedure is as follows, with each line numbered sequentially (e.g., 1. 2. 3. 4. 5. 6. etc.):\n1. Call KMPSearch(pat[0] = A, pat[1] = A, pat[2] = A, txt[0] = C, txt[1] = B, txt[2] = B, txt[3] = C).\n", "output": "[]", "pat": "AAA", "txt": "CBBC", "N": 4, "M": 3, "intermediate_results": [0, 1, 2]}
{"input": "Execute the instructions step by step. Do not jump steps. Do not stop before completion. When reading or updating an array at some index, use concrete values rather than just variables.\n\nInitial: Given a pattern string pat of length M and a text string txt of length N.\npat: pat[0] = A, pat[1] = A, pat[2] = B, M = 3.\ntxt: txt[0] = C, txt[1] = A, txt[2] = A, txt[3] = B, N = 4.\nCreate an array lps[] of length M with the value of 0: lps[0] = 0, lps[1] = 0, lps[2] = 0.\n\ndef KMPSearch(pat, txt):\n    # pat is a string of length M, and txt is a string of length N.\n    M = len(pat)\n    N = len(txt)\n \n    # create lps[] that will hold the longest prefix suffix\n    # values for pattern\n    lps = [0] * M\n\n \n    # Preprocess the pattern (calculate lps[] array)\n    length = 0  # length of the previous longest prefix suffix\n \n    i = 1\n \n    # the loop calculates lps[i] for i = 1 to M-1\n    while i < M:\n        if pat[i] == pat[length]:\n            length += 1\n            lps[i] = length\n            i += 1\n        else:\n            # This is tricky. Consider the example.\n            # AAACAAAA and i = 7. The idea is similar\n            # to search step.\n            if length != 0:\n                length_prev = length - 1\n                length = lps[length_prev]\n \n                # Also, note that we do not increment i here\n            else:\n                lps[i] = 0\n                i += 1\n    # End of while loop\n\n    print(lps) # And print lps[], displaying each value as \"lps[i] = lps_i\".\n \n    i = 0  # index for txt[]\n    j = 0  # index for pat[]\n    res = []\n\n    while (N - i) >= (M - j):\n        if pat[j] == txt[i]:\n            i += 1\n            j += 1\n        # End of if\n \n        if j == M:\n            found_index = i - j\n            res.append(found_index) # And print res\n            j = lps[j-1]\n        # End of j == M\n\n        # mismatch after j matches\n        elif i < N and pat[j] != txt[i]:\n            # Do not match lps[0..lps[j-1]] characters,\n            # they will match anyway\n            if j != 0:\n                j = lps[j-1]\n            else:\n                i += 1\n        # End of elif\n    # End of while\n\n    return res\n\n-----\nThe computation procedure is as follows, with each line numbered sequentially (e.g., 1. 2. 3. 4. 5. 6. etc.):\n1. Call KMPSearch(pat[0] = A, pat[1] = A, pat[2] = B, txt[0] = C, txt[1] = A, txt[2] = A, txt[3] = B).\n", "output": "[1]", "pat": "AAB", "txt": "CAAB", "N": 4, "M": 3, "intermediate_results": [0, 1, 0]}
{"input": "Execute the instructions step by step. Do not jump steps. Do not stop before completion. When reading or updating an array at some index, use concrete values rather than just variables.\n\nInitial: Given a pattern string pat of length M and a text string txt of length N.\npat: pat[0] = A, pat[1] = B, pat[2] = A, M = 3.\ntxt: txt[0] = B, txt[1] = A, txt[2] = A, txt[3] = C, N = 4.\nCreate an array lps[] of length M with the value of 0: lps[0] = 0, lps[1] = 0, lps[2] = 0.\n\ndef KMPSearch(pat, txt):\n    # pat is a string of length M, and txt is a string of length N.\n    M = len(pat)\n    N = len(txt)\n \n    # create lps[] that will hold the longest prefix suffix\n    # values for pattern\n    lps = [0] * M\n\n \n    # Preprocess the pattern (calculate lps[] array)\n    length = 0  # length of the previous longest prefix suffix\n \n    i = 1\n \n    # the loop calculates lps[i] for i = 1 to M-1\n    while i < M:\n        if pat[i] == pat[length]:\n            length += 1\n            lps[i] = length\n            i += 1\n        else:\n            # This is tricky. Consider the example.\n            # AAACAAAA and i = 7. The idea is similar\n            # to search step.\n            if length != 0:\n                length_prev = length - 1\n                length = lps[length_prev]\n \n                # Also, note that we do not increment i here\n            else:\n                lps[i] = 0\n                i += 1\n    # End of while loop\n\n    print(lps) # And print lps[], displaying each value as \"lps[i] = lps_i\".\n \n    i = 0  # index for txt[]\n    j = 0  # index for pat[]\n    res = []\n\n    while (N - i) >= (M - j):\n        if pat[j] == txt[i]:\n            i += 1\n            j += 1\n        # End of if\n \n        if j == M:\n            found_index = i - j\n            res.append(found_index) # And print res\n            j = lps[j-1]\n        # End of j == M\n\n        # mismatch after j matches\n        elif i < N and pat[j] != txt[i]:\n            # Do not match lps[0..lps[j-1]] characters,\n            # they will match anyway\n            if j != 0:\n                j = lps[j-1]\n            else:\n                i += 1\n        # End of elif\n    # End of while\n\n    return res\n\n-----\nThe computation procedure is as follows, with each line numbered sequentially (e.g., 1. 2. 3. 4. 5. 6. etc.):\n1. Call KMPSearch(pat[0] = A, pat[1] = B, pat[2] = A, txt[0] = B, txt[1] = A, txt[2] = A, txt[3] = C).\n", "output": "[]", "pat": "ABA", "txt": "BAAC", "N": 4, "M": 3, "intermediate_results": [0, 0, 1]}
{"input": "Execute the instructions step by step. Do not jump steps. Do not stop before completion. When reading or updating an array at some index, use concrete values rather than just variables.\n\nInitial: Given a pattern string pat of length M and a text string txt of length N.\npat: pat[0] = A, pat[1] = B, pat[2] = B, M = 3.\ntxt: txt[0] = A, txt[1] = B, txt[2] = B, txt[3] = B, N = 4.\nCreate an array lps[] of length M with the value of 0: lps[0] = 0, lps[1] = 0, lps[2] = 0.\n\ndef KMPSearch(pat, txt):\n    # pat is a string of length M, and txt is a string of length N.\n    M = len(pat)\n    N = len(txt)\n \n    # create lps[] that will hold the longest prefix suffix\n    # values for pattern\n    lps = [0] * M\n\n \n    # Preprocess the pattern (calculate lps[] array)\n    length = 0  # length of the previous longest prefix suffix\n \n    i = 1\n \n    # the loop calculates lps[i] for i = 1 to M-1\n    while i < M:\n        if pat[i] == pat[length]:\n            length += 1\n            lps[i] = length\n            i += 1\n        else:\n            # This is tricky. Consider the example.\n            # AAACAAAA and i = 7. The idea is similar\n            # to search step.\n            if length != 0:\n                length_prev = length - 1\n                length = lps[length_prev]\n \n                # Also, note that we do not increment i here\n            else:\n                lps[i] = 0\n                i += 1\n    # End of while loop\n\n    print(lps) # And print lps[], displaying each value as \"lps[i] = lps_i\".\n \n    i = 0  # index for txt[]\n    j = 0  # index for pat[]\n    res = []\n\n    while (N - i) >= (M - j):\n        if pat[j] == txt[i]:\n            i += 1\n            j += 1\n        # End of if\n \n        if j == M:\n            found_index = i - j\n            res.append(found_index) # And print res\n            j = lps[j-1]\n        # End of j == M\n\n        # mismatch after j matches\n        elif i < N and pat[j] != txt[i]:\n            # Do not match lps[0..lps[j-1]] characters,\n            # they will match anyway\n            if j != 0:\n                j = lps[j-1]\n            else:\n                i += 1\n        # End of elif\n    # End of while\n\n    return res\n\n-----\nThe computation procedure is as follows, with each line numbered sequentially (e.g., 1. 2. 3. 4. 5. 6. etc.):\n1. Call KMPSearch(pat[0] = A, pat[1] = B, pat[2] = B, txt[0] = A, txt[1] = B, txt[2] = B, txt[3] = B).\n", "output": "[0]", "pat": "ABB", "txt": "ABBB", "N": 4, "M": 3, "intermediate_results": [0, 0, 0]}
{"input": "Execute the instructions step by step. Do not jump steps. Do not stop before completion. When reading or updating an array at some index, use concrete values rather than just variables.\n\nInitial: Given a pattern string pat of length M and a text string txt of length N.\npat: pat[0] = A, pat[1] = B, pat[2] = C, M = 3.\ntxt: txt[0] = A, txt[1] = B, txt[2] = C, txt[3] = C, N = 4.\nCreate an array lps[] of length M with the value of 0: lps[0] = 0, lps[1] = 0, lps[2] = 0.\n\ndef KMPSearch(pat, txt):\n    # pat is a string of length M, and txt is a string of length N.\n    M = len(pat)\n    N = len(txt)\n \n    # create lps[] that will hold the longest prefix suffix\n    # values for pattern\n    lps = [0] * M\n\n \n    # Preprocess the pattern (calculate lps[] array)\n    length = 0  # length of the previous longest prefix suffix\n \n    i = 1\n \n    # the loop calculates lps[i] for i = 1 to M-1\n    while i < M:\n        if pat[i] == pat[length]:\n            length += 1\n            lps[i] = length\n            i += 1\n        else:\n            # This is tricky. Consider the example.\n            # AAACAAAA and i = 7. The idea is similar\n            # to search step.\n            if length != 0:\n                length_prev = length - 1\n                length = lps[length_prev]\n \n                # Also, note that we do not increment i here\n            else:\n                lps[i] = 0\n                i += 1\n    # End of while loop\n\n    print(lps) # And print lps[], displaying each value as \"lps[i] = lps_i\".\n \n    i = 0  # index for txt[]\n    j = 0  # index for pat[]\n    res = []\n\n    while (N - i) >= (M - j):\n        if pat[j] == txt[i]:\n            i += 1\n            j += 1\n        # End of if\n \n        if j == M:\n            found_index = i - j\n            res.append(found_index) # And print res\n            j = lps[j-1]\n        # End of j == M\n\n        # mismatch after j matches\n        elif i < N and pat[j] != txt[i]:\n            # Do not match lps[0..lps[j-1]] characters,\n            # they will match anyway\n            if j != 0:\n                j = lps[j-1]\n            else:\n                i += 1\n        # End of elif\n    # End of while\n\n    return res\n\n-----\nThe computation procedure is as follows, with each line numbered sequentially (e.g., 1. 2. 3. 4. 5. 6. etc.):\n1. Call KMPSearch(pat[0] = A, pat[1] = B, pat[2] = C, txt[0] = A, txt[1] = B, txt[2] = C, txt[3] = C).\n", "output": "[0]", "pat": "ABC", "txt": "ABCC", "N": 4, "M": 3, "intermediate_results": [0, 0, 0]}
{"input": "Execute the instructions step by step. Do not jump steps. Do not stop before completion. When reading or updating an array at some index, use concrete values rather than just variables.\n\nInitial: Given a pattern string pat of length M and a text string txt of length N.\npat: pat[0] = A, pat[1] = A, pat[2] = A, M = 3.\ntxt: txt[0] = A, txt[1] = A, txt[2] = A, txt[3] = A, txt[4] = B, N = 5.\nCreate an array lps[] of length M with the value of 0: lps[0] = 0, lps[1] = 0, lps[2] = 0.\n\ndef KMPSearch(pat, txt):\n    # pat is a string of length M, and txt is a string of length N.\n    M = len(pat)\n    N = len(txt)\n \n    # create lps[] that will hold the longest prefix suffix\n    # values for pattern\n    lps = [0] * M\n\n \n    # Preprocess the pattern (calculate lps[] array)\n    length = 0  # length of the previous longest prefix suffix\n \n    i = 1\n \n    # the loop calculates lps[i] for i = 1 to M-1\n    while i < M:\n        if pat[i] == pat[length]:\n            length += 1\n            lps[i] = length\n            i += 1\n        else:\n            # This is tricky. Consider the example.\n            # AAACAAAA and i = 7. The idea is similar\n            # to search step.\n            if length != 0:\n                length_prev = length - 1\n                length = lps[length_prev]\n \n                # Also, note that we do not increment i here\n            else:\n                lps[i] = 0\n                i += 1\n    # End of while loop\n\n    print(lps) # And print lps[], displaying each value as \"lps[i] = lps_i\".\n \n    i = 0  # index for txt[]\n    j = 0  # index for pat[]\n    res = []\n\n    while (N - i) >= (M - j):\n        if pat[j] == txt[i]:\n            i += 1\n            j += 1\n        # End of if\n \n        if j == M:\n            found_index = i - j\n            res.append(found_index) # And print res\n            j = lps[j-1]\n        # End of j == M\n\n        # mismatch after j matches\n        elif i < N and pat[j] != txt[i]:\n            # Do not match lps[0..lps[j-1]] characters,\n            # they will match anyway\n            if j != 0:\n                j = lps[j-1]\n            else:\n                i += 1\n        # End of elif\n    # End of while\n\n    return res\n\n-----\nThe computation procedure is as follows, with each line numbered sequentially (e.g., 1. 2. 3. 4. 5. 6. etc.):\n1. Call KMPSearch(pat[0] = A, pat[1] = A, pat[2] = A, txt[0] = A, txt[1] = A, txt[2] = A, txt[3] = A, txt[4] = B).\n", "output": "[0, 1]", "pat": "AAA", "txt": "AAAAB", "N": 5, "M": 3, "intermediate_results": [0, 1, 2]}
{"input": "Execute the instructions step by step. Do not jump steps. Do not stop before completion. When reading or updating an array at some index, use concrete values rather than just variables.\n\nInitial: Given a pattern string pat of length M and a text string txt of length N.\npat: pat[0] = A, pat[1] = A, pat[2] = B, M = 3.\ntxt: txt[0] = B, txt[1] = A, txt[2] = A, txt[3] = B, txt[4] = C, N = 5.\nCreate an array lps[] of length M with the value of 0: lps[0] = 0, lps[1] = 0, lps[2] = 0.\n\ndef KMPSearch(pat, txt):\n    # pat is a string of length M, and txt is a string of length N.\n    M = len(pat)\n    N = len(txt)\n \n    # create lps[] that will hold the longest prefix suffix\n    # values for pattern\n    lps = [0] * M\n\n \n    # Preprocess the pattern (calculate lps[] array)\n    length = 0  # length of the previous longest prefix suffix\n \n    i = 1\n \n    # the loop calculates lps[i] for i = 1 to M-1\n    while i < M:\n        if pat[i] == pat[length]:\n            length += 1\n            lps[i] = length\n            i += 1\n        else:\n            # This is tricky. Consider the example.\n            # AAACAAAA and i = 7. The idea is similar\n            # to search step.\n            if length != 0:\n                length_prev = length - 1\n                length = lps[length_prev]\n \n                # Also, note that we do not increment i here\n            else:\n                lps[i] = 0\n                i += 1\n    # End of while loop\n\n    print(lps) # And print lps[], displaying each value as \"lps[i] = lps_i\".\n \n    i = 0  # index for txt[]\n    j = 0  # index for pat[]\n    res = []\n\n    while (N - i) >= (M - j):\n        if pat[j] == txt[i]:\n            i += 1\n            j += 1\n        # End of if\n \n        if j == M:\n            found_index = i - j\n            res.append(found_index) # And print res\n            j = lps[j-1]\n        # End of j == M\n\n        # mismatch after j matches\n        elif i < N and pat[j] != txt[i]:\n            # Do not match lps[0..lps[j-1]] characters,\n            # they will match anyway\n            if j != 0:\n                j = lps[j-1]\n            else:\n                i += 1\n        # End of elif\n    # End of while\n\n    return res\n\n-----\nThe computation procedure is as follows, with each line numbered sequentially (e.g., 1. 2. 3. 4. 5. 6. etc.):\n1. Call KMPSearch(pat[0] = A, pat[1] = A, pat[2] = B, txt[0] = B, txt[1] = A, txt[2] = A, txt[3] = B, txt[4] = C).\n", "output": "[1]", "pat": "AAB", "txt": "BAABC", "N": 5, "M": 3, "intermediate_results": [0, 1, 0]}
{"input": "Execute the instructions step by step. Do not jump steps. Do not stop before completion. When reading or updating an array at some index, use concrete values rather than just variables.\n\nInitial: Given a pattern string pat of length M and a text string txt of length N.\npat: pat[0] = A, pat[1] = B, pat[2] = A, M = 3.\ntxt: txt[0] = C, txt[1] = B, txt[2] = A, txt[3] = B, txt[4] = B, N = 5.\nCreate an array lps[] of length M with the value of 0: lps[0] = 0, lps[1] = 0, lps[2] = 0.\n\ndef KMPSearch(pat, txt):\n    # pat is a string of length M, and txt is a string of length N.\n    M = len(pat)\n    N = len(txt)\n \n    # create lps[] that will hold the longest prefix suffix\n    # values for pattern\n    lps = [0] * M\n\n \n    # Preprocess the pattern (calculate lps[] array)\n    length = 0  # length of the previous longest prefix suffix\n \n    i = 1\n \n    # the loop calculates lps[i] for i = 1 to M-1\n    while i < M:\n        if pat[i] == pat[length]:\n            length += 1\n            lps[i] = length\n            i += 1\n        else:\n            # This is tricky. Consider the example.\n            # AAACAAAA and i = 7. The idea is similar\n            # to search step.\n            if length != 0:\n                length_prev = length - 1\n                length = lps[length_prev]\n \n                # Also, note that we do not increment i here\n            else:\n                lps[i] = 0\n                i += 1\n    # End of while loop\n\n    print(lps) # And print lps[], displaying each value as \"lps[i] = lps_i\".\n \n    i = 0  # index for txt[]\n    j = 0  # index for pat[]\n    res = []\n\n    while (N - i) >= (M - j):\n        if pat[j] == txt[i]:\n            i += 1\n            j += 1\n        # End of if\n \n        if j == M:\n            found_index = i - j\n            res.append(found_index) # And print res\n            j = lps[j-1]\n        # End of j == M\n\n        # mismatch after j matches\n        elif i < N and pat[j] != txt[i]:\n            # Do not match lps[0..lps[j-1]] characters,\n            # they will match anyway\n            if j != 0:\n                j = lps[j-1]\n            else:\n                i += 1\n        # End of elif\n    # End of while\n\n    return res\n\n-----\nThe computation procedure is as follows, with each line numbered sequentially (e.g., 1. 2. 3. 4. 5. 6. etc.):\n1. Call KMPSearch(pat[0] = A, pat[1] = B, pat[2] = A, txt[0] = C, txt[1] = B, txt[2] = A, txt[3] = B, txt[4] = B).\n", "output": "[]", "pat": "ABA", "txt": "CBABB", "N": 5, "M": 3, "intermediate_results": [0, 0, 1]}
{"input": "Execute the instructions step by step. Do not jump steps. Do not stop before completion. When reading or updating an array at some index, use concrete values rather than just variables.\n\nInitial: Given a pattern string pat of length M and a text string txt of length N.\npat: pat[0] = A, pat[1] = B, pat[2] = B, M = 3.\ntxt: txt[0] = C, txt[1] = A, txt[2] = B, txt[3] = B, txt[4] = B, N = 5.\nCreate an array lps[] of length M with the value of 0: lps[0] = 0, lps[1] = 0, lps[2] = 0.\n\ndef KMPSearch(pat, txt):\n    # pat is a string of length M, and txt is a string of length N.\n    M = len(pat)\n    N = len(txt)\n \n    # create lps[] that will hold the longest prefix suffix\n    # values for pattern\n    lps = [0] * M\n\n \n    # Preprocess the pattern (calculate lps[] array)\n    length = 0  # length of the previous longest prefix suffix\n \n    i = 1\n \n    # the loop calculates lps[i] for i = 1 to M-1\n    while i < M:\n        if pat[i] == pat[length]:\n            length += 1\n            lps[i] = length\n            i += 1\n        else:\n            # This is tricky. Consider the example.\n            # AAACAAAA and i = 7. The idea is similar\n            # to search step.\n            if length != 0:\n                length_prev = length - 1\n                length = lps[length_prev]\n \n                # Also, note that we do not increment i here\n            else:\n                lps[i] = 0\n                i += 1\n    # End of while loop\n\n    print(lps) # And print lps[], displaying each value as \"lps[i] = lps_i\".\n \n    i = 0  # index for txt[]\n    j = 0  # index for pat[]\n    res = []\n\n    while (N - i) >= (M - j):\n        if pat[j] == txt[i]:\n            i += 1\n            j += 1\n        # End of if\n \n        if j == M:\n            found_index = i - j\n            res.append(found_index) # And print res\n            j = lps[j-1]\n        # End of j == M\n\n        # mismatch after j matches\n        elif i < N and pat[j] != txt[i]:\n            # Do not match lps[0..lps[j-1]] characters,\n            # they will match anyway\n            if j != 0:\n                j = lps[j-1]\n            else:\n                i += 1\n        # End of elif\n    # End of while\n\n    return res\n\n-----\nThe computation procedure is as follows, with each line numbered sequentially (e.g., 1. 2. 3. 4. 5. 6. etc.):\n1. Call KMPSearch(pat[0] = A, pat[1] = B, pat[2] = B, txt[0] = C, txt[1] = A, txt[2] = B, txt[3] = B, txt[4] = B).\n", "output": "[1]", "pat": "ABB", "txt": "CABBB", "N": 5, "M": 3, "intermediate_results": [0, 0, 0]}
{"input": "Execute the instructions step by step. Do not jump steps. Do not stop before completion. When reading or updating an array at some index, use concrete values rather than just variables.\n\nInitial: Given a pattern string pat of length M and a text string txt of length N.\npat: pat[0] = A, pat[1] = B, pat[2] = C, M = 3.\ntxt: txt[0] = A, txt[1] = B, txt[2] = C, txt[3] = A, txt[4] = C, N = 5.\nCreate an array lps[] of length M with the value of 0: lps[0] = 0, lps[1] = 0, lps[2] = 0.\n\ndef KMPSearch(pat, txt):\n    # pat is a string of length M, and txt is a string of length N.\n    M = len(pat)\n    N = len(txt)\n \n    # create lps[] that will hold the longest prefix suffix\n    # values for pattern\n    lps = [0] * M\n\n \n    # Preprocess the pattern (calculate lps[] array)\n    length = 0  # length of the previous longest prefix suffix\n \n    i = 1\n \n    # the loop calculates lps[i] for i = 1 to M-1\n    while i < M:\n        if pat[i] == pat[length]:\n            length += 1\n            lps[i] = length\n            i += 1\n        else:\n            # This is tricky. Consider the example.\n            # AAACAAAA and i = 7. The idea is similar\n            # to search step.\n            if length != 0:\n                length_prev = length - 1\n                length = lps[length_prev]\n \n                # Also, note that we do not increment i here\n            else:\n                lps[i] = 0\n                i += 1\n    # End of while loop\n\n    print(lps) # And print lps[], displaying each value as \"lps[i] = lps_i\".\n \n    i = 0  # index for txt[]\n    j = 0  # index for pat[]\n    res = []\n\n    while (N - i) >= (M - j):\n        if pat[j] == txt[i]:\n            i += 1\n            j += 1\n        # End of if\n \n        if j == M:\n            found_index = i - j\n            res.append(found_index) # And print res\n            j = lps[j-1]\n        # End of j == M\n\n        # mismatch after j matches\n        elif i < N and pat[j] != txt[i]:\n            # Do not match lps[0..lps[j-1]] characters,\n            # they will match anyway\n            if j != 0:\n                j = lps[j-1]\n            else:\n                i += 1\n        # End of elif\n    # End of while\n\n    return res\n\n-----\nThe computation procedure is as follows, with each line numbered sequentially (e.g., 1. 2. 3. 4. 5. 6. etc.):\n1. Call KMPSearch(pat[0] = A, pat[1] = B, pat[2] = C, txt[0] = A, txt[1] = B, txt[2] = C, txt[3] = A, txt[4] = C).\n", "output": "[0]", "pat": "ABC", "txt": "ABCAC", "N": 5, "M": 3, "intermediate_results": [0, 0, 0]}
